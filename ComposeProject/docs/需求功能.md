# GPU Block-Kriging × PINN 耦合重建 - 需求功能分析

## 1. 项目概述

本项目旨在将GPU加速的Block Kriging与Physics-Informed Neural Network (PINN)深度融合，实现3D辐射场高精度重建。

## 2. 现有模块接口分析

### 2.1 Kriging模块 (`Kriging/`)

#### 可复用接口
```python
# 主要函数接口
def training(df, variogram_model="linear", nlags=8, enable_plotting=False, 
             weight=False, uk=False, cpu_on=False)
    """训练克里金模型
    输入: DataFrame(x,y,z,target), 参数配置
    输出: 训练好的模型对象
    """

def testing(df, model, block_size=10000, cpu_on=False, style="gpu_b", 
            multi_process=False, print_time=False, torch_ac=False, compute_precision=True)
    """测试/预测克里金模型
    输入: 测试点DataFrame, 训练好的模型
    输出: 预测值数组, 真实值数组
    """

# 主要类接口
class MyOrdinaryKriging3D(OrdinaryKriging3D):
    def __init__(self, x, y, z, val, variogram_model="linear", ...)
    def execute(self, style, xpoints, ypoints, zpoints, mask=None, 
                backend="vectorized", n_closest_points=None, block_size=10000, ...)
        """GPU加速的克里金执行
        返回: (预测值, 方差) - 注意：当前实现可能不完全支持全局σ²输出
        """
```

#### 待改写部分
- [ ] **不确定度支持**: 当前`execute()`方法返回的方差`ss`需要验证是否为完整的全局σ²
- [ ] **接口标准化**: 需要封装为标准的`fit(X, y)` + `predict(X)` + `predict_with_uncertainty(X)`接口
- [ ] **数据格式统一**: 将DataFrame输入/输出统一为numpy数组格式

### 2.2 PINN模块 (`PINN/`)

#### 可复用接口
```python
# 数据处理
class RadiationDataProcessor:
    def load_from_dict(self, data_dict, space_dims=None, world_bounds=None)
    def normalize_data(self, method='robust')
    def get_dose_data(self)

class DataLoader:
    @staticmethod
    def sample_training_points(dose_data, num_samples=300, sampling_strategy='positive_weighted')

# PINN训练
class PINNTrainer:
    def __init__(self, physical_params=None)
    def create_pinn_model(self, dose_data, sampled_points_xyz, sampled_log_doses_values, 
                         include_source=False, network_config=None, ...)
    def train(self, epochs=10000, use_lbfgs=True, loss_weights=None, display_every=500)
    def predict(self, prediction_points)

# 结果分析
class ResultAnalyzer:
    @staticmethod
    def evaluate_predictions(dose_pinn_grid, dose_mc_data, pinn_grid_coords, ...)
```

#### 待改写部分
- [ ] **残差计算接口**: 需要新增计算PINN预测与真实测点残差的方法
- [ ] **预测输出标准化**: 统一预测结果的数据格式和坐标系

## 3. 耦合方案需求

### 3.1 方案1: PINN → 残差Kriging → 加权融合

**流程**:
1. 用N个测点训练PINN → 全场预测
2. 计算N个训练点的残差 (真实值 - PINN预测值)
3. 用Kriging对残差进行插值 → 全场残差预测
4. 最终预测 = PINN预测 + ω×残差预测, ω∈(0,1)

**需新增接口**:
```python
def residual_kriging(train_points, train_values, pinn_predictions, prediction_points, **kriging_params)
    """残差克里金插值
    输入: 训练点坐标, 真实值, PINN预测值, 预测点坐标
    输出: 残差预测值, 残差方差(如支持)
    """

def fuse_residual(pinn_pred, kriging_residual, weight=0.5, uncertainty=None)
    """加权融合PINN预测和残差
    输入: PINN预测, 残差预测, 权重, 不确定度(可选)
    输出: 融合预测, 置信界(如支持)
    """
```

### 3.2 方案2: Kriging在ROI生成新样本 → 扩充数据 → 重新训练PINN

**流程**:
1. 识别相关区域(Region of Interest, ROI)
2. 在ROI内用Kriging训练和预测 → 生成M>N个"准真值"点
3. 将原始N点 + 新增(M-N)点作为扩充训练集
4. 用扩充训练集重新训练PINN → 全场预测

**需新增接口**:
```python
def detect_roi(train_points, train_values, roi_strategy='high_density')
    """检测相关区域
    输入: 训练点, 训练值, ROI策略
    输出: ROI边界坐标
    """

def augment_by_kriging(train_points, train_values, roi_bounds, augment_factor=2.0, **kriging_params)
    """在ROI内用Kriging生成新样本
    输入: 原始训练集, ROI范围, 扩充倍数
    输出: 扩充后的训练点坐标, 扩充后的训练值
    """
```

## 4. 通用工具需求

### 4.1 数据类型标准化
```python
class FieldTensor:
    """标准化的场数据结构"""
    coordinates: np.ndarray  # (N, 3) - xyz坐标
    values: np.ndarray      # (N,) - 场值
    uncertainties: Optional[np.ndarray]  # (N,) - 不确定度
    metadata: Dict          # 元数据

class ProbeSet:
    """标准化的测点数据结构"""
    positions: np.ndarray   # (N, 3) - 测点坐标
    measurements: np.ndarray # (N,) - 测量值
    weights: Optional[np.ndarray]  # (N,) - 权重
```

### 4.2 误差统计与可视化
```python
def compute_metrics(true_values, pred_values, metrics=['MAE', 'RMSE', 'MAPE'])
def visualize_comparison(true_field, pred_field, uncertainty_field=None)
def plot_residual_analysis(residuals, coordinates)
```

## 5. 实现优先级

### Phase 1: 基础接口重构
1. 统一Kriging和PINN的输入/输出数据格式
2. 封装标准化的`fit`/`predict`接口
3. **重要**: 验证并修复Kriging不确定度σ²输出问题

### Phase 2: 方案1实现
1. 实现`residual_kriging()`功能
2. 实现`fuse_residual()`加权融合
3. 端到端测试方案1流程

### Phase 3: 方案2实现
1. 实现`detect_roi()`区域检测
2. 实现`augment_by_kriging()`样本扩充
3. 端到端测试方案2流程

### Phase 4: 优化与发布
1. 性能基准测试
2. 不确定度验证(如实现)
3. 文档完善与API发布

## 6. 关键技术难点

1. **Kriging不确定度**: 需要确认当前GPU实现是否正确输出全局方差σ²
2. **坐标系统一**: 确保Kriging和PINN使用相同的坐标系和单位
3. **内存管理**: GPU加速时的显存管理和数据传输优化
4. **数值稳定性**: 大规模矩阵求解的数值稳定性保证

## 7. 测试策略

1. **单元测试**: 每个新增接口的独立测试
2. **集成测试**: 两种耦合方案的端到端测试
3. **性能测试**: GPU加速效果的基准测试
4. **数值验证**: 与理论解或高精度参考解的对比

---

**交付物**: 本文档作为ComposeProject开发的需求规格，指导后续的接口设计和实现工作。 